"""
La stratégie à suivre: faire des mise à jour à deux sites,
le coté "arrière" est multiplié par la racinne quatrième de la somme des carré des valeurs singulière, 
le coté "avant" est contracté avec les valeurs singulière et divisé par la quatrième racine des la somme des carrées des valeur singulière.
Les tenseurs environnements doivent être normalisé de sorte à évité l'apparition de la norme total dans la mise à jours.

"""


class Env_holder:
    """
    class to hold the MPTs that makes up the enviroments of a 1d-sweeping tensor algorithm.
    Takes care of the fiddling with the site index. The environment generated by the tensors at site i can be accessed by using [j,i] where j is the jth environment List
    """

    def __init__(self, env):
        self.env = env

    def __getitem__(self, i: tuple[int, int]):
        i, j = i
        return self.env[i][j + 1]

    def __setitem__(self, i: tuple[int, int], value):
        i, j = i
        self.env[i][j + 1] = value


import quimb.tensor as qtn
from typing import List
import numpy as np
from .generate_simple_MPO import generate_id_MPO


def Nroots_prediction(norms: np.array) -> float:
    """Compute the second order approximation to the Nth root of the product of the supplied list. Nth roots rapidly converge to 1 as N increase with finite precision arithmetic. This approximation should be more accurate than the direct computation with double precision floats"""
    # could be computed exactly using logarithms and exponentials... but it wouldn't save us from doing it repeatedly, and this is cheaper.
    av = np.mean(norms)
    deltas = norms - av
    N = len(norms)
    x = -np.sum(deltas**2)
    x = x / (av * N * (N - 1))
    return av + x


def guess_tensor_norm(target_norms, norm2, oc, direction):
    """guess the N root of the norm of the MPO from the norms of the individual tensors and the norm of the update. The value converge exponentially fast in the network optimization procedure."""
    target_norms[oc] = norm2
    target_norms[oc + direction] = norm2
    target_norm_root = Nroots_prediction(
        target_norms
    )  ## doit être m-a-j avec les tenseur de target. L'algo suppose que target_norm_root^L est la norm du réseau cible.
    a = 1
    b = (norm2 < target_norm_root) * (
        np.abs(np.log(norm2 / target_norm_root))
    )  # when norm2 is small, it pays to reduce the norm faster.
    target_norm_root = (a * target_norm_root + b * norm2) / (
        a + b
    )  ##injecting the average to speedup norm distribution convergence, not using just it to reduce overshooting oscillation
    target_norms[oc] = target_norm_root
    target_norms[oc + direction] = target_norm_root
    norm = np.sqrt(target_norm_root)
    return norm


def compute_oc(MPO: qtn.MatrixProductOperator) -> tuple[int, int]:
    tmp_id = qtn.rand_uuid()
    forward = True
    center = [0, 0]
    for i, _ in enumerate(MPO):
        # il faut tout contracter sauf le lien.
        t = MPO[i]
        if forward and i == MPO.L - 1:
            center = [i, i]
            break
        if forward:
            bond_name = MPO.bond(i, i + 1)
            center[0] = i
        else:
            bond_name = MPO.bond(i - 1, i)
        tp = qtn.Tensor(t.H)
        tp.reindex_({bond_name: tmp_id})
        X = (t | tp).contract()
        is_center = not np.allclose(
            X.data / X.data.flatten()[0], np.eye(X.data.shape[0]), rtol=1.0e-12
        )
        if is_center:
            forward = False
            center[1] = i
    return tuple(center)


def move_oc(MPO: qtn.MatrixProductOperator, dest: int):
    if dest < 0:
        dest = MPO.L + dest
    assert dest < MPO.L
    assert dest >= 0
    oc = [*compute_oc(MPO)]
    while oc[0] < dest:
        t = MPO[oc[0]]
        bond = MPO.bond(oc[0], oc[0] + 1)
        u, d, v = t.split(left_inds=None, right_inds=[bond], absorb=None)
        dd = np.sqrt(d @ d)
        d /= dd
        dv = (d | v).contract(output_inds=v.inds)
        dv.drop_tags(dv.tags)
        MPO[oc[0]] = u * dd
        MPO[oc[0] + 1] = MPO[oc[0] + 1] @ dv
        oc[0] += 1
    while oc[1] > dest:
        t = MPO[oc[1]]
        bond = MPO.bond(oc[1] - 1, oc[1])
        u, d, v = t.split(left_inds=[bond], absorb=None)
        dd = np.sqrt(d @ d)
        d /= dd
        du = (d | u).contract(output_inds=u.inds)
        du.drop_tags(du.tags)
        MPO[oc[1] - 1] = MPO[oc[1] - 1] @ du
        MPO[oc[1]] = v * dd
        oc[1] -= 1


def sum_sweep(
    MPOs: List[qtn.MatrixProductOperator],
    target: qtn.MatrixProductOperator,
    envs,
    direction,
    tol,
    oc,
    target_norms,
    max_bond,
):

    Env = Env_holder(envs)
    starting_oc = oc
    L = target.L
    direction = 1
    if oc == L - 1:
        direction = -1
    count = 0
    while True:
        indexshift = (direction - 1) // 2
        Tens = (
            Env[0, oc + indexshift - 1]
            | MPOs[0][oc + indexshift]
            | MPOs[0][oc + indexshift + 1]
            | Env[0, oc + indexshift + 2]
        ).contract()
        for i, t in enumerate(MPOs[1:]):
            Tens += (
                Env[i + 1, oc + indexshift - 1]
                | MPOs[i + 1][oc + indexshift]
                | MPOs[i + 1][oc + indexshift + 1]
                | Env[i + 1, oc + indexshift + 2]
            ).contract()
        n = len(MPOs[0][oc + direction].inds) - 1
        if direction == 1:
            right_inds, left_inds = Tens.inds[-n:], None
        else:
            right_inds, left_inds = None, Tens.inds[:n]
        U, d, V = qtn.tensor_split(
            Tens,
            right_inds=right_inds,
            left_inds=left_inds,
            absorb=None,
            cutoff=tol,
            max_bond=max_bond,
        )
        if direction == 1:
            N = U
        else:
            N = V
        norm2 = np.sqrt(d @ d)
        norm = guess_tensor_norm(target_norms, norm2, oc, direction)
        N *= norm
        N.drop_tags()
        for tag in target[oc].tags:
            N.add_tag(tag)
        target[oc] = N  ## besoin d'adaptation pour gérer la norme
        for i, t in enumerate(MPOs):  ## besoin d'adaptation pour gérer la norme
            Env[i, oc] = (
                target[oc].H | t[oc] | Env[i, oc - direction]
            ).contract() / norm**2
            assert len(Env[i, oc].inds) == 2

        oc += direction
        direction = direction - 2 * (oc == (L - 1) or oc == 0) * direction

        if oc == starting_oc:
            tags = target[oc].tags
            tmp = (Env[0, oc - 1] | MPOs[0][oc] | Env[0, oc + 1]).contract()
            for i, t in enumerate(MPOs[1:]):
                tmp += (Env[i + 1, oc - 1] | t[oc] | Env[i + 1, oc + 1]).contract()
            tmp.drop_tags()
            for tag in tags:
                tmp.add_tag(tag)
            target[oc] = tmp
            break
        count += 1
    out = target[oc] @ target[oc].H
    return out


def order_one_square_root(
    MPO: qtn.MatrixProductOperator, tol: float, crit: float, max_bond=None
):
    """compute an order one approximation to the square root of MPO assuming its eigenvalues are in the domain [0,1].
    This approximation is better starting point for newton's method than order_two_square_root if it is know
    that no eigenvalues are close to zero."""
    zero = generate_id_MPO(MPO.lower_ind_id, MPO.upper_ind_id, MPO.L, factor=0.23570226)
    one = MPO * 2 * 0.40824829
    return MPO_compressing_sum([zero, one], tol, crit, max_bond)


def order_two_square_root(
    MPO: qtn.MatrixProductOperator, tol: float, crit: float, max_bond
):
    """compute an order two approximation to the square root of MPO assuming its eigenvalues are in the domain [0,1]
    This approximation sacrifice some precision far from zero to increase it near zero.
    Newton's procedure has trouble converging near zero. This compromise speeds up convergence near
    zero very significantly without sacrificing too much close to 1. In the Scalar case, about 8 iteration of newton's
    procedure is more than enough to converge the whole domain to an absolute and relative error of 1e-16.
    One must be careful to avoid division by zero when there are null eigenvalues. Typical pseudo-inverse methods should be safe."""
    one = 3.425800798515744 * MPO
    two = -2.6352313834736494 * MPO.apply(MPO)
    return MPO_compressing_sum([one, two], tol, crit, max_bond)


def cpt_sqrt_left_env(varL, cL, out, target, up_ind, dn_ind):
    ##VARL update
    A, B, Ad, Bd, c = setup_index_left_sqrt_var(varL, out, target, up_ind, dn_ind)
    out_varL = (varL | B | Bd | Ad | A).contract()
    ##cL update
    out_cL = (cL | c | Bd | Ad).contract()
    return out_varL, out_cL


def setup_index_left_sqrt_var(varL, out, target, up_ind, dn_ind):
    B = out.copy()
    left_ind = set(B.inds).intersection(varL.inds)
    right_ind = set(B.inds).difference([*left_ind, up_ind, dn_ind])
    A = out.copy()
    right_ind = right_ind.pop()
    A_reind = {up_ind: up_ind + "a", dn_ind: up_ind, right_ind: right_ind + "a"}
    Bd_reind = {up_ind: up_ind + "uad", right_ind: right_ind + "bd"}
    Ad_reind = {
        dn_ind: up_ind + "uad",
        up_ind: up_ind + "a",
        right_ind: right_ind + "ad",
    }
    if len(left_ind) == 1:  # not at boundary
        left_ind = left_ind.pop()
        A_reind[left_ind] = left_ind + "a"
        Bd_reind[left_ind] = left_ind + "bd"
        Ad_reind[left_ind] = left_ind + "ad"
    Ad = A.H
    A.reindex_(A_reind)
    Bd = B.H
    Bd.reindex_(Bd_reind)
    Ad.reindex_(Ad_reind)
    c = target.reindex({up_ind: up_ind + "a"})
    return A, B, Ad, Bd, c


def setup_index_right_sqrt_var(
    varR: qtn.Tensor, out: qtn.Tensor, target: qtn.Tensor, up_ind: str, dn_ind: str
):
    B = out.copy()
    right_ind = set(B.inds).intersection(varR.inds)
    left_ind = set(B.inds).difference([*right_ind, up_ind, dn_ind])
    assert len(right_ind) <= 1 and len(left_ind) == 1
    left_ind = left_ind.pop()
    A = out.copy()
    A_reind = {up_ind: up_ind + "a", dn_ind: up_ind, left_ind: left_ind + "a"}
    Bd_reind = {up_ind: up_ind + "uad", left_ind: left_ind + "bd"}
    Ad_reind = {dn_ind: up_ind + "uad", up_ind: up_ind + "a", left_ind: left_ind + "ad"}
    if len(right_ind) == 1:
        right_ind = right_ind.pop()
        A_reind[right_ind] = right_ind + "a"
        Bd_reind[right_ind] = right_ind + "bd"
        Ad_reind[right_ind] = right_ind + "ad"
    Ad = A.H
    A.reindex_(A_reind)
    Bd = B.H
    Bd.reindex_(Bd_reind)
    Ad.reindex_(Ad_reind)
    ##cR update
    c = target.reindex({up_ind: up_ind + "a"})
    return A, B, Ad, Bd, c


def cpt_sqrt_right_env(varR, cR, out, target, up_ind, dn_ind):
    A, B, Ad, Bd, c = setup_index_right_sqrt_var(varR, out, target, up_ind, dn_ind)
    ##VARR update
    out_varR = (varR | B | Bd | Ad | A).contract()
    ##cR update
    out_cR = (cR | c | Bd | Ad).contract()
    return out_varR, out_cR


def init_sqrt_env(out, target, oc, up_ind: str, dn_ind: str, target_norms):
    varL = [qtn.Tensor()]
    cL = [qtn.Tensor()]
    i = 0
    while i < oc:
        vl, cl = cpt_sqrt_left_env(
            varL[-1],
            cL[-1],
            out[i] / target_norms[i],
            target[i],
            up_ind.format(i),
            dn_ind.format(i),
        )
        varL.append(vl)
        cL.append(cl)
        i += 1
    i = out.L - 1
    varR = [qtn.Tensor()]
    cR = [qtn.Tensor()]
    while i > oc:
        vr, cr = cpt_sqrt_right_env(
            varR[-1],
            cR[-1],
            out[i] / target_norms[i],
            target[i],
            up_ind.format(i),
            dn_ind.format(i),
        )
        varR.append(vr)
        cR.append(cr)
        i -= 1
    varR.reverse()
    cR.reverse()
    return Env_holder([[*varL, None, *varR]]), Env_holder([[*cL, None, *cR]])


def linsolve(T, C, precision):
    """Penrose pseudo-inverse"""
    left_inds = set(T.inds).intersection(C.inds)
    U, d, V = qtn.tensor_split(T, left_inds=left_inds, absorb=None, cutoff=precision)
    dm = 1 / d  # penrose pseudo inverse
    cu, cd, cv = qtn.tensor_split(
        C,
        left_inds=set(V.inds).union(U.inds).intersection(C.inds),
        absorb=None,
        cutoff=None,
    )
    o_inds = set(T.inds).symmetric_difference(C.inds)
    O = (U.H | dm | V.H | C).contract(output_inds=o_inds)  # a/x_n
    return O


def sqrt_sweep(
    out: qtn.MatrixProductOperator,
    target,
    VarEnv,
    Cenv,
    oc,
    direction,
    target_norms,
    tol,
    max_bond,
):
    count = 0
    starting_oc = oc
    L = out.L
    while True:
        indexshift = (direction - 1) // 2
        up_indn = out.upper_ind_id.format(oc + indexshift)
        dn_indn = out.lower_ind_id.format(oc + indexshift)
        up_indnp = out.upper_ind_id.format(oc + indexshift + 1)
        dn_indnp = out.lower_ind_id.format(oc + indexshift + 1)
        vL = VarEnv[0, oc - 1 + indexshift]
        cL = Cenv[0, oc - 1 + indexshift]
        On = out[oc + indexshift]
        Onp = out[oc + indexshift + 1]
        tn = target[oc + indexshift]
        tnp = target[oc + indexshift + 1]
        vR = VarEnv[0, oc + 2 + indexshift]
        cR = Cenv[0, oc + 2 + indexshift]
        An, Bn, Adn, Bdn, cn = setup_index_left_sqrt_var(vL, On, tn, up_indn, dn_indn)
        Anp, Bnp, Adnp, Bdnp, cnp = setup_index_right_sqrt_var(
            vR, Onp, tnp, up_indnp, dn_indnp
        )
        T = (vL | Adn | An | Adnp | Anp | vR).contract()
        C = (cL | cn | Adn | Adnp | cnp | cR).contract()
        xn = (Bn | Bnp).contract()
        O = linsolve(T, C, tol)
        O = (O + xn) / 2
        out_left_inds = set(Bn.inds).difference(Bnp.inds)
        U, d, V = qtn.tensor_split(O, out_left_inds, absorb=None, cutoff=tol)
        norm2 = np.sqrt(d @ d)
        norm = guess_tensor_norm(target_norms, norm2, oc, direction)
        d /= norm
        U.drop_tags()
        V.drop_tags()
        d.drop_tags()
        for tag in out[oc + indexshift].tags:
            U.add_tag(tag)
        for tag in out[oc + 1 + indexshift].tags:
            V.add_tag(tag)
        if direction == 1:
            VarEnv[0, oc + indexshift], Cenv[0, oc + indexshift] = cpt_sqrt_left_env(
                vL, cL, U, target[oc + indexshift], up_indn, dn_indn
            )
            Cenv[0, oc + indexshift] /= norm**2
            V = (V | d).contract(output_inds=V.inds)
            U *= norm
        else:
            (
                VarEnv[0, oc + indexshift + 1],
                Cenv[0, oc + indexshift + 1],
            ) = cpt_sqrt_right_env(
                vR, cR, V, target[oc + indexshift + 1], up_indnp, dn_indnp
            )
            Cenv[0, oc + indexshift + 1] /= norm**2
            U = (U | d).contract(output_inds=U.inds)
            V *= norm

        out[oc + indexshift] = U
        out[oc + indexshift + 1] = V

        oc += direction
        direction = direction - 2 * (oc == (L - 1) or oc == 0) * direction

        if oc == starting_oc:
            err = xn - O
            err = err @ err.H
            break
        count += 1
    return err


def Square_Root(
    MPO: qtn.MatrixProductOperator, tol: float, crit: float, max_bond=None, out=None
):
    """compute the square root of the supplied MPO using newton's iterative formula."""
    # first order solution:
    if out is None:
        out = order_two_square_root(MPO, tol, crit, max_bond)
    cost = 100000
    new_cost = 1000
    oc = compute_oc(out)
    if oc[1] == oc[0]:
        oc = oc[1]
    else:
        oc = 0
    if oc == out.L:
        direction = -1
    else:
        direction = 1
    norms = [x @ x.H for x in out]
    tgt_norm = np.mean(norms)
    varEnv, Cenv = init_sqrt_env(
        out, MPO, oc, out.upper_ind_id, out.lower_ind_id, target_norms=norms
    )
    iter_count = 0
    while (np.abs(new_cost - cost) > tol or cost > 1) and iter_count < 200:
        cost = new_cost
        new_cost = sqrt_sweep(
            out, MPO, varEnv, Cenv, oc, direction, norms, crit, max_bond
        )
        print(cost)
        iter_count += 1
    print(norms)
    return out


def Embed_in_unitaryMPO(
    MPO: qtn.MatrixProductOperator, tol: float, crit: float, max_bond=None
):
    inL = MPO.L
    outL = inL + 1
    P = qtn.Tensor(
        data=[[1, 0], [0, 0]],
        inds=(MPO.lower_ind_id.format(inL), MPO.upper_ind_id.format(inL)),
        tags=[MPO.site_tag_id.format(inL)],
    )
    Out = qtn.MPO_rand(outL, 4, 2, dtype=MPO.dtype)
    norms = [x @ x.H for x in Out]
    tgt_norm = np.mean(norms)
    # The next tree line accomplish this: MPOp = qtn.MatrixProductOperator(MPO|P)
    # wut keep the result in a MPO
    Nm1shape = MPO[-1].data.shape
    Nm1shape = (Nm1shape[0], 1, *Nm1shape[1:])
    MPOp = qtn.MatrixProductOperator(
        [
            *[MPO[i].data for i, t in enumerate(MPO.tensors[0:-1])],
            MPO[-1].data.reshape(Nm1shape),
            P.data.reshape(1, *P.data.shape),
        ],
        lower_ind_id=MPO.lower_ind_id,
        upper_ind_id=MPO.upper_ind_id,
        site_tag_id=MPO.site_tag_id,
    )
    MPOenv = mpompo_env_prep(Out, MPOp, tgt_norm, 0)
    Pout = (Out | P).contract(P.tags)
    OOenv = mpompo_env_prep(
        Pout, Pout, tgt_norm, 0
    )  # No env contrib for the ancilla qbit.
    cost = 1.0e18
    new_cost = 0
    direction = 1
    iter_count = 0
    oc = 0
    while True:
        new_cost = Embed_sweep(
            MPOp, Out, OOenv, MPOenv, direction, tol, oc, norms, max_bond=max_bond
        )
        if abs(2 * (new_cost - cost) / (new_cost + cost)) < crit:
            break
        cost = new_cost
        iter_count += 1
        if iter_count > 1000:
            print("Compressing sum failed to converge")
            break
    print("iterations: ", iter_count)
    return Out


def Embed_sweep(MPOp, Out, OOenv, MPOEnv, direction, tol, oc, norms, max_bond):
    pass


def mpompo_env_prep(mpoA, mpoB, target_norm, oc):
    L = mpoA.L
    outleft = []
    outleft.append(qtn.Tensor(data=1, inds=()))
    for i in range(oc):
        outleft.append((outleft[-1] | mpoA[i].H | mpoB[i]).contract() / target_norm)
    outright = []
    outright.append(qtn.Tensor(data=1, inds=()))
    for i in range(L - 1, oc, -1):
        outright.append((outright[-1] | mpoA[i].H | mpoB[i]).contract() / target_norm)
    outright.reverse()
    return outleft + [qtn.Tensor()] + outright


def MPO_compressor(
    MPO: qtn.MatrixProductOperator, tol: float, crit: float, max_bond=None
):
    return MPO_compressing_sum([MPO], tol, crit, max_bond)


def MPO_compressing_sum(
    MPOs: List[qtn.MatrixProductOperator], tol: float, crit: float, max_bond=None
):
    # check free indices are compatible across all input MPS
    mpo0 = MPOs[0]
    N = mpo0.L
    tens_arr = [
        np.random.rand(
            4,
            4,
            mpo0[c].ind_size(mpo0.upper_ind_id.format(c)),
            mpo0[c].ind_size(mpo0.lower_ind_id.format(c)),
        )
        for c, x in enumerate(mpo0)
    ]
    tens_arr[0] = tens_arr[0][0, :, :, :]
    tens_arr[-1] = tens_arr[-1][:, 0, :, :]
    mpsi_n = 0
    for mpsi in MPOs[1:]:
        assert mpsi.L == N
        c = 0
        while c < N:
            x = mpsi[c]
            sup = x.ind_size(mpsi.upper_ind_id.format(c))
            sdn = x.ind_size(mpsi.lower_ind_id.format(c))
            assert sup == tens_arr[c].shape[-2]
            assert sdn == tens_arr[c].shape[-1]
            c += 1
        mpsi.upper_ind_id = mpo0.upper_ind_id
        mpsi.lower_ind_id = mpo0.lower_ind_id
        mpsi_n += 1
    out = qtn.MatrixProductOperator(
        tens_arr,
        shape="lrud",
        upper_ind_id=mpo0.upper_ind_id,
        lower_ind_id=mpo0.lower_ind_id,
        site_tag_id="out{}",
    )
    oc = compute_oc(MPOs[0])
    if oc[0] == oc[1]:
        oc = oc[0]
    else:
        oc = 0
    norms = [x @ x.H for x in out]
    tgt_norm = np.mean(norms)
    envs = [mpompo_env_prep(out, m, tgt_norm, oc) for m in MPOs]
    cost = 1.0e18
    new_cost = 0
    direction = 1
    iter_count = 0
    while True:
        new_cost = sum_sweep(
            MPOs, out, envs, direction, tol, oc, norms, max_bond=max_bond
        )
        if abs(2 * (new_cost - cost) / (new_cost + cost)) < crit:
            break
        cost = new_cost
        iter_count += 1
        if iter_count > 1000:
            print("Compressing sum failed to converge")
            break
    print("iterations: ", iter_count)
    print(norms)
    return out


if __name__ == "__main__":
    pass

import quimb.tensor as qtn
import numpy as np
from typing import List


def retag(X:qtn.Tensor,tags):
    X.drop_tags()
    for tag in tags: 
        X.add_tag(tag)

def layer_SVD_optimizer(layer:qtn.TensorNetwork,layer_left_indices:list[str],accu:qtn.MatrixProductOperator,mpo:qtn.MatrixProductOperator,Layer_tag_id:str,max_it:int,prec:float,*,renorm:bool=True,return_error:bool=False):
    n = mpo.L
    # layer_left_output_inds = set([mpo.lower_ind_id.format(i) for i in range(n)])
    # accu_left_inds = set(accu.upper_ind_id.format(i) for i in range(n) )
    Ntens = len(layer.tensors)
    layertags = [Layer_tag_id.format(i) for i in range(Ntens)]
    err = 1000
    it = 0
    direction = 1
    pos = 0
    Ltags = [Layer_tag_id.format(pos) for pos in range(Ntens)]
    curr_err = 1e6
    while it<max_it and curr_err > prec:
        it+=1
        # print("direction ",direction)
        for i in range(Ntens):
            curr_A = Ltags[pos]
            # print("tensor to update: ",curr_A)
            accuH = accu.H
            if renorm:
                for t in accuH.tensors[:-2]:
                    t /= 2
            X = mpo|accu.H|layer.H
            # X.draw()
            TBDtags = set(X.tags).difference(layer[curr_A].tags)
            TBd = X.contract(TBDtags)
            update_tags = set(TBd.tags).difference(layer[curr_A].tags)
            T = TBd.contract(update_tags)
            T = T[update_tags]
            left_inds = layer_left_indices[curr_A]
            U,d,V = T.split(left_inds,cutoff = 0.0,absorb=None)#normalize...
            T = U@V
            # print(T@T.H)
            E = layer[curr_A] - T #Better error computation is possible.
            err = (d-1).sum_reduce(d.inds[0]).data
            retag(T,layer[curr_A].tags)
            layer[curr_A] = T
            # upd,d = layer_upd(B,H,layer[curr_A],oli,iri)
            pos += direction
        if abs(err) < prec:
            break
        curr_err = err
        ##
        direction *= -1
        pos += direction
        # print(iterative_projection_infidelity(T.select_any(layertags),accu,mpo))
        # print(iterative_projection_infidelity(normalize_gates(T.select_any(layertags)),accu,mpo))
    if return_error:
        return layer.select_any(layertags),curr_err
    return layer.select_any(layertags)

class Env_holder:
    """
    class to hold the MPTs that makes up the enviroments of a 1d-sweeping tensor algorithm.
    Takes care of the fiddling with the site index. The environment generated by the tensors at site i can be accessed by using [j,i] where j is the jth environment List
    """
    def __init__(self,env):
        self.env = env

    def __getitem__(self,i:tuple[int,int]):
        i,j = i
        return self.env[i][j+1]

    def __setitem__(self,i:tuple[int,int],value):
        i,j = i
        self.env[i][j+1] = value

def mpsmps_env_prep(mpsA:qtn.MatrixProductState,mpsB:qtn.MatrixProductState):
    outleft = []
    outleft.append(qtn.Tensor(data = 1,inds = ()))
    oc = mpsA.calc_current_orthog_center()
    if oc[0] == oc[1]:
        oc = oc[0]
    else:
        oc = mpsA.L-1
    for i in range(oc):
        outleft.append((outleft[-1]|mpsA[i].H|mpsB[i]).contract())
    outright = []
    outright.append(qtn.Tensor(data = 1,inds = ()))
    for i in range(mpsA.L - oc - 1):
        outright.append((outright[-1]|mpsA[-i-1].H|mpsB[-i-1]).contract())
    outright.reverse()
    return outleft+[qtn.Tensor()]+outright

def sum_sweep(MPSes:List[qtn.MatrixProductState],target:qtn.MatrixProductState,envs,direction,tol,oc):
    Env = Env_holder(envs)
    starting_oc = oc
    L = target.L
    if oc == 0:
        direction = -1
    if oc == L-1:
        direction = 1
    while True:
        direction  = direction - 2*(oc == (L-1) or oc==0)*direction
        if direction == 1:
            Tens = (Env[0,oc-1]|MPSes[0][oc]|MPSes[0][oc+1]|Env[0,oc+2]).contract()
            for i,t in enumerate(MPSes[1:]):
                Tens += (Env[i+1,oc-1]|MPSes[i+1][oc]|MPSes[i+1][oc+1]|Env[i+1,oc+2]).contract()
            n = len(MPSes[0][oc+1].inds)-1
            U,d,V = qtn.tensor_split(Tens,right_inds=Tens.inds[-n:],left_inds=None,absorb=None,cutoff=tol)
            U.drop_tags()
            for tag in target[oc].tags:
                U.add_tag(tag)
            target[oc] = U
            for i,t in enumerate(MPSes):
                Env[i,oc] = (target[oc].H|t[oc]|Env[i,oc-1]).contract()
                assert(len(Env[i,oc].inds) == 2)
        else:
            Tens = (Env[0,oc-2]|MPSes[0][oc-1]|MPSes[0][oc]|Env[0,oc+1]).contract()
            for i,t in enumerate(MPSes[1:]):
                Tens += (Env[i+1,oc-2]|MPSes[i+1][oc-1]|MPSes[i+1][oc]|Env[i+1,oc+1]).contract()
            n = len(MPSes[0][oc-1].inds)-1
            U,d,V = qtn.tensor_split(Tens,left_inds=Tens.inds[:n],cutoff=tol,absorb=None)
            V.drop_tags()
            for tag in target[oc].tags:
                V.add_tag(tag)
            target[oc] = V
            for i,t in enumerate(MPSes):
                Env[i,oc] = (target[oc].H|t[oc]|Env[i,oc+1]).contract()
                assert(len(Env[i,oc].inds) == 2)
            
        oc += direction

        if oc == starting_oc:
            tags = target[oc].tags
            tmp = (Env[0,oc-1]| MPSes[0][oc]|Env[0,oc+1]).contract()
            for i,t in enumerate(MPSes[1:]):
                tmp += (Env[i+1,oc-1]|t[oc]|Env[i+1,oc+1]).contract()
            tmp.drop_tags()
            for tag in tags:
                tmp.add_tag(tag)
            target[oc] = tmp
            break
    out = target[oc]@target[oc].H
    return out

def MPS_compressing_sum(MPSes:List[qtn.MatrixProductState],target_norm2:float,tol:float,crit:float):
    #check free indices are compatible across all input MPS
    mps0 = MPSes[0]
    N = mps0.L
    tens_arr = [np.random.rand(4,4,x.ind_size(mps0.site_ind_id.format(c))) for c,x in enumerate(mps0)]
    tens_arr[0] = tens_arr[0][0,:,:]
    tens_arr[-1] = tens_arr[-1][:,0,:]
    for mpsi in MPSes[1:]:
        assert(mpsi.L == N)
        c = 0
        for x in mpsi:
            s = x.ind_size(mpsi.site_ind_id.format(c))
            assert(s == tens_arr[c].shape[-1])
            c += 1
        mpsi.site_ind_id = mps0.site_ind_id

    # other shape format than lrp are buggy. it always convert to lrp, and it doesn't treat edge tensor correctly when converting.
    out = qtn.MatrixProductState(tens_arr,shape='lrp',site_ind_id=mps0.site_ind_id,site_tag_id='out{}')
    oc = out.calc_current_orthog_center()
    if oc[0] == oc[1]:
        oc = oc[0]
    else:
        oc = out.L-1
    envs = [mpsmps_env_prep(out,m) for m in MPSes]
    new_cost = 0
    direction = 1
    iter_count = 0
    while True:
        sum_sweep_out = sum_sweep(MPSes,out,envs,direction,tol,oc)
        new_cost = target_norm2 - sum_sweep_out
        if new_cost < crit:
            break
        iter_count += 1
        if (iter_count > 1000):
            print("Compressing sum failed to converge")
            break
    return out

def MPS_compression(MPS:qtn.MatrixProductState,target_norm2:float,tol:float,crit:float):
    return MPS_compressing_sum([MPS],target_norm2,tol,crit)